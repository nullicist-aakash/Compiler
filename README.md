# Compiler

## Overview and Requirements
This project was done as part of Compiler course in BITS Pilani. This was a semester long project and we had to implement the following in the group of 3:
1. Lexer.
2. Parser using `LL(1)` grammar.
3. Semantic Analysis and type checking.
4. Code generation to assembly.


## Stage 1
### Lexical Analysis
Rules are mentioned in PDF folder.

### Syntactic Analysis
Rules are mentioned in PDF folder.

## Stage 2
The following requirements were mentioned for the project:
### Abstract Syntax Tree
This module takes as input the parse tree produced by the parser and generates a memory efficient abstract syntax tree (AST). The abstract syntax tree is generated by traversing the parse tree (one pass) eliminating unnecessary details such as semicolon, colon, comma, parenthesis, square brackets, assignment operator etc. The AST preserves the syntactic structure of a construct for code generation. The AST retains only those children which are essential for semantic analysis. The long chains of unnecessary nodes are collapsed. The leaf nodes of the AST still continue to contain the tokens and other relevant information extracted.

Prepare semantic rules to obtain AST for each construct and implement. For implementation, you may have to modify the structure of the parse tree nodes.

### Symbol Table (ST)
This module takes as input the abstract syntax tree generated as above. Symbol table is a special data structure that maintains information about the identifiers (variables that participate in computation as the source code is executed). The information gathered during semantic analysis phase is extremely valuable for generating the assembly language code for the input source code. Variables declared in different static scopes are maintained in separate symbol tables corresponding to the scopes appropriately. 

Implement Symbol Table to incorporate following information for all identifiers:
1. Type (and aliases)
2. width
3. Scope
4. offset etc.

The variable identifiers are defined within the static scope of a function definition.

### Type Extractor and Checker
The language supports static and dynamic type checking. All constructs except the union and variant records are type checked statically. The type of variables of variant record type are dynamically checked while the variables of union type cannot be type checked at any time. Similar applies to the parameters types. The parameter passing technique used is pass-by-value. 

#### Static type checking
Type of an identifier is extracted from the declaration statement that declares the identifier. The data types supported in the language you are implementing are: integer, real, record, union and variant records. The type checker verifies the type of an expression appearing at the right hand side of the assignment statement and checks if it matches with that of the identifier on the left hand side. An arithmetic operator can have two operands of the similar type, where types can be integer and real data types.

The general type checking rules are:
1. The type of an identifier is the type appearing while declaring the variable.
2. The type of `TK_NUM` is integer.
3. The type of `TK_RNUM` is real.
4. The type of an identifier of a record type expanded with a dot followed by the field name is same as that of the field.
5. The type of a record type is a tuple (type of field1, type of field 2, type of field3,.......and so on). Consider the following type definition:
    ```
    record #circle
      type real :  x;
      type int:  y;
      type real: radius;
      type real: area;
    endrecord
    ```

    The type of the above record is `(real, int, real, real)` (say `T`). Extend this representation for nested union and record types as well appropriately.
6. The type of a simple expression (say `E`) of the form `expression(say E1) <operator> Expression (say E2)` is
   - integer, if both expressions are of type integer and the operator is any of the arithmetic operators +, -, *.
   - real, if both the expressions are of type real and the operator is arithmetic operators +, - and *. 
   - real, if both the expressions are of type real and the operator is arithmetic operator /
   - real, if both the expressions are of type int and the operator is arithmetic operators /
   - real, if one expression is of integer type and the other expression is of type real and the operator is arithmetic operators /
   - boolean, if both expressions are of type integer and the operator is relational operator.
   - boolean, if both expressions are of type real and the operator is relational.
   - boolean, if both expressions are of type boolean and the operator is logical.
   - record type T if both E1 and E2 are of the same record type T.
   - The type of an identifier of union data type is reported as an error.
   - The type of an identifier of aliases of union or record types are same as those of their basic respective types. For example,
      ```
      definetype union #student as #newname;
      definetype record #book as #newbook;
      ```
      Here, the types union #student and #newname are equivalent.
    - Presence of the discriminator for a variant record is ascertained using the field name tagvalue specifically. If a variant record definition does not have a field described as tagvalue, then it is captured at compile time and reported as an error.
    - The type of tagvalue field is integer. If it is of real type or record type then it is reported as error.
    - The type of the expression is ERROR, if the above rules do not derive the type of E appropriately. The type of an identifier or an expression is computed by traversing the abstract syntax tree.
    - The structure of union data type is captured at compile time, but the relevant field type is used at run time based on the tagvalue.

#### Dynamic type checking

The variables of variant record type are type checked at run time based on the value of the field tagvalue. If the tag value is 1, the first field of the union data type (of variant part) is used. If the tag value is 2, then the second field of the union data type is used. This is sequentially applicable for all fields of the variant part. Consider for example,
```
union #student
  type int: rollno;
  type real: marks;
  type int: roomno;
endunion

definetype union #student as #newname;
record #variantrecord
  type int: x;
  type real: y;
  type int: tagvalue;
  type int z;
  type #newname: s;
endrecord
```
Then consider the variable declarations as given below.

```
type record #variantrecord : b2c4;
type record #variantrecord : b2c5;
type record #variantrecord : b2c6;

b2c4.tagvalue = 2;  % use of tagvalue 2 for the second field marks of the union to be used at run time
b2c4.s.marks = 34.98;
b2c5.tagvalue = 2;
b2c5.s.marks = 56.76; %if the above tagvalue was 1, this line would have been reported as an error at run time.
b2c6 = b2c4+b2c5;
 % as these variables are of variant record type, the type checking will be done at the run time and only the appropriate operation on the corresponding field marks will be performed at run time.
```

The above logic also applies for parameter passing while handling the variables of variant record types.

#### Semantic Analyzer
This module verifies the semantics of the code.

  - An identifier cannot be declared multiple times in the same scope.
  - An identifier must be declared before its use.
  - An identifier declared globally cannot be declared anywhere else in function definitions.
  - The types and the number of parameters returned by a function must be the same as that of the parameters used in invoking the function.
  - The parameter passed of union data type is reported as error.
  - The parameter of variant record type (for variant field only) is type checked at run type as described above.
  - A variant record passed as a parameter must have a discriminator named as tagvalue.
  - The parameters being returned by a function must be assigned a value. If a parameter does not get a value assigned within the function definition, it should be reported as an error.
  - The function that does not return any value, must be invoked appropriately.
  - The types of formal and actual parameters must be same.
  - Number of actual parameters must be same as that of formal parameters.
  - Function overloading is not allowed.
  - The function cannot be invoked recursively.
  - An identifier used beyond its scope must be viewed as undefined
  - A record type definition is visible anywhere in the program.
  - The right hand side expression of an assignment statement must be of the same type as that of the left hand side identifier.
  - A function definition for a function being used (say F1) by another (say F2) must precede the definition of the function using it(i.e. F2).
  - A while statement must redefine the variable that participates in the iterations. As an instance, consider the following example
    ```
    while (c3 <= c5)
      write(c3);
      c3 <‐‐‐ c3 + 2.34;
    end
    ```

#### Code Generator
This module takes as input the abstract syntax tree (AST) as intermediate representation. The function generates 8086 assembly code. In addition to emitting the assembly code, the code generator generates the dynamic type checking sequences for use of variables of variant record type.

All features of the language such as iterative and conditional constructs, all statement constructs, function calls, all types of variables (including records and variant records etc.), expression evaluation etc. exist in the source code.

Only trivial optimization such as avoiding redundant code, appropriate register usage etc. are needed while the detailed code optimization techniques are not expected to be implemented.

### Implementation Updates
#### Function Prototypes and File Names
Function prototypes are flexible. Students are advised to use names of data structures such as ast, parseTree, symbolTable, quadruple etc. appropriately. You can select names of implementation files appropriately from file names ast.c, symbolTable.c, typeExtractor.c, semantics.c, codegen.c etc. You can have additional files, if you need as support, but the name of the file must be indicative of the contents within it.

The function prototype declarations should be in file *.h corresponding to the implementation file name [ For example , if you are naming the interface file for the functions in symbolTable.c, name that interface file as symbolTable.h]. The data definitions should also be split in the files appropriately as symbolTableDef.h. etc.

#### Intermediate Code Generation

Teams can generate assembly language code by first constructing the intermediate code using instructions given in text book or can generate the code directly. [The process of code generation through intermediate code generation is more systematic and produces correct code while direct code generation may be erroneous.] However, there is no extra credit for IR (Intermediate Representation) creation as it is left to the decision of teams as to whether to generate code through IR or by skipping IR . The correctness of the generated code will be of significance.

#### Instruction Set

Your compiler must generate equivalent assembly code (in file code.asm) with instructions taken from instruction set of the NASM simulator (linux based). Use NASM (http://www.nasm.us/) to verify correctness of the output obtained by executing assembly code generated by your compiler for the user source code in given toy language. 

#### Efficiency

Efficiency (Time and Space ) is an expected feature of your compiler code. Design efficient data structure for symbol table etc. Abstract Syntax Tree (AST) is a copy of the user source code in concrete form and semantic analysis is expected to be done by traversing the AST instead of traversing the parse tree. While constructing AST, the unused nodes of the parse tree can be freed. The semantic analysis, type checking and code generation rules are usually based on the constructs (sub trees) of the AST. Compatibility with the GCC version specified during stage 1 must be ensured.


### Driver, Makefile and execution details
#### Driver
Your driver of integrated compiler must have the following ELEVEN choices. The options should be independent of each other.
0. To exit from the loop (Ask for the choices in a loop)
1. For printing the token list generated by the lexer (on the console)
2. For parsing to verify the syntactic correctness of the input source code and to produce parse tree (On Console)
3. For printing the Abstract Syntax Tree in appropriate format. Also specify the traversal order at the beginning. (On Console)
4. For displaying the amount of allocated memory and number of nodes to each of parse tree and abstract syntax tree for the test case used.
   The format for step 4 should be as per the example given below:
   ```
     Parse tree Number of nodes = 150 Allocated Memory = 1024 Bytes
     AST Number of nodes = 30 Allocated Memory = 200 Bytes
     Compression percentage = ((1024 ‐ 200) / 1024) * 100
   ```
   (use `sizeof()` to compute size of allocated memory while allocate memory during construction of these trees)
5. Symbol Table: For printing the Symbol Table giving following information (eight in number) for each variable identifier at each line using formatted output. [Use width of variables of type integer as 2 and of real as 4 for printing the symbol table] 
   - name: Variable name 
   - Scope: module name
   - type name: if variable is of record type, then print name of record definition and also print all the names of aliases used for the record definition, e.g. if definetype record  #abc as #def, then print #abc, #pqr. If more name equivalent aliases of record type were defined anywhere in the program, mention all.
   - type expression: Print type of variable (if primitive then print int or real as applied, if record, then print as a cartesian product e.g. <int, real, int>, if nested record - use angular bracket pair as appropriate.For example - <int, real, <real, real, int>>. 
   - width: if the variable is of record type, then total sum of width of all field, if the variable is of type variant record, then print the sum of fixed length fields plus the maximum of all field widths used in variant part) 
   - isGlobal: if variable is global, print global else print --- (three hyphens)
   - offset: Include input and output parameters prior to all local variables and start offsets from 0 onwards.[if the variable is global, its offset is taken from the global perspective, and not computed from local perspective]
variable usage - If the variable is local, then print "local", if the variable is an input parameter, then print "input parameter" and if the variable is an output parameter, then print "output parameter".
   - If an entry is not applicable, then mark three hyphen marks as ---
   
   Once the symbol table is completely populated, use printSymbolTable() to print the contents of that by traversing that and print appropriately. It is absolutely acceptable that the variables may not appear in the same order as they appeared in the test case code, provided their computed offsets genuinely verify the ordering of variables in the test case. However, variable sequence from one scope should not be overlapped with that of another scope.  

6. Global variables: For printing the list of all global variables, their types and offsets (starts with 0 in the function scope)

7. Activation record sizes: For printing the total memory requirement (sum total of widths of all variables in the function scope) for each function. The format is as follows
   ```
   _fun1   18
   _new    34
   .... and so on
   ```
8. Record types and sizes: For printing the type expressions and width of globally visible record definitions. Example format
   ```
   #new          <int, real>          6
   #finance      <int, real, int>     8
   and so on ......
   ```

9. Type checking and semantic analysis: For compiling to verify the syntactic and semantic correctness of the input source code If the code is syntactically incorrect, report all syntax errors only. If the code is syntactically correct, then report ALL type checking and semantic errors (continue traversing the AST after detecting and reporting type and semantic errors). Also print (on the console) the total time taken by your integrated compiler. Print both total_CPU_time and total_CPU_time_in_seconds (as mentioned earlier)

10. Code generation and dynamic type checking: For producing assembly code (Linux based NASM will be used for execution) (assuming that there is no syntactic, semantic or type mismatch errors in the test cases).

    - Perform actions appropriately by invoking appropriate functions. All lexical, syntax and semantic errors including type mismatch errors must be reported appropriately on the console (Standard output) ONLY and not in any file unless otherwise specified.

    - The very first line on the console, as your compiler code executes, should contain a message regarding the status of your work such as
      
      ```LEVEL #: Message```
      
      where # is any one index in ${1,2,3,4}$ and the message is Symbol table/type Checking/ Semantic rules module(s) work(s) (specify one or many as applicable). The level specification is according to the total number of semantic rules you could successfully implement. The measure for the total number of semantic rules (type checking and semantic ) is as per the number of errors you could target. However, This level of message does not count on the syntax errors (which however are to be reported if exist).

    - Specify LEVEL as
      
      1, if less than or equal to 5 ERRORs out of all errors could be successfully handled
      
      2, if 6‐10 ERRORs could be implemented
      
      3, if 11‐15 ERRORs could be implemented
      
      4, if 16 or more ERRORs could be implemented

    - LEVEL 2: Symbol table/ AST/ Semantic Rules modules work. This means that you were able to implement the symbol table, AST and semantic rules handling 6‐10 semantic errors in total, but you could not implement type checking successfully (subject to verification).
      
      The complete ERROR list (with line numbers first) should be printed on the console if the code is syntactically or semantically incorrect, else print a message

      ```
      Code compiles successfully ..........
      ```
      
#### Compilation

The name of the make file should be makefile only as I will avoid using ‐f option always to make your file named something else (that includes searching for the file which is time taking). The evaluation of your code will be done using the GCC version as specified earlier. Please ensure compatibility. All errors including lexical errors, syntax errors and semantic errors should be displayed on the console with line numbers.

#### Execution

The command line argument for execution of the driver should be as follows, for example

```
$./compiler testcase.txt code.asm
```

where compiler is the executable generated after linking all the files (your makefile should be absolutely correct). Also, the testcase.txt is the input source code (in the language you are implementing) file to be compiled. code.asm is the output file containing the assembly language code (NASM ‐64 bits compatible) equivalent to the input source code. Testing of the Resultant code in assembly language is done on a simulator NASM 2.15.05. The Instruction Set Architecture of NASM should be used for the target code. Only standard assembly code instructions will be allowed and use of any other C library with NASM will not be allowed strictly.

### Errata
1. The division operator is no longer valid with record variables. Also, scalar multiplication with record type variable will be valid only with integer values of the scalar (and not of real values) . 
2. The variant record will have exactly one variant part (i.e. union part) so as to be able to handle the tag using tagvalue field.
3. The record definitions are not cyclic. For example, record #abc using record #pqr definition for its fields and record  #pqr using record #abc for its field definitions will not be valid. However, record definitions continue to be nested as earlier.
4. Please change small e to E in the real numbers lexemes given in test cases p1-p4, wherever applicable.


## Success?
The project was extremely successful and we got almost all the cases covered that were given in the requirements.
