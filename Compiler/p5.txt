

%Test Case 1: Type checking 
%Details: 
%        (a) Simple arithmetic expressions involvoing primitive data types are used in this test case
%        (b) Only main module is used and no other function is used in this test case
%	 (c) All variables are declared once only before their use
%        (d) The variables participating in the expression need not be initialized any values. Only test cases for code generation will have all values initialized or read appropriately.
% The errors are reported by me in the test cases right in front of the corresponding line in comment form. 
% It is essential for you to report errors with LINE NUMBERS correctly.	 

%The following source code is expected to be syntactically correct as per the modified grammar.
%If any line has syntax error, please inform me as that error needs to be fixed in this test case.
%record variable int to real not allowed
%record scalar multi allowed
%int real mult not allowed
%division tests - real int , int real, real real, int int -> all LHS real - assign to int then error
%boolean testcases - int comparison with real not allowed
%logical op between int and real not allowed
%if record has union, record should have tagvalue
%type of tagvalue is integer

_unionfunction  input parameter list [record #two d5cc34, #point b5c6]  
output parameter list[#real d3];

	record #two
		type #point: beginpoint;
		type #point: endpoint;
	endrecord


	type record #two : b5b567;
	type record #one : b3;
	type #poe: d5;
	b5b567 <--- b5c6*2;
	b3 <--- b5c6-d5cc34;
	while ( b5b567 <= d5cc34)
		read(d5cc34);
		d3 <--- d3 + d5cc34;
		b5b567 <--- b5b567 + 1;
	endwhile
	return [d3];
end

_intersectionfunction  input parameter list [union #four d5cc34, #yash b5c6]  
output parameter list[union #four d7];

	record #two
		type #point: beginpoint;
		type #point: endpoint;
	endrecord


	type record #two : b5b567;
	type record #one : b3;
	type #poe: d5;
	b5b567 <--- b5c6*2;
	b3 <--- b5c6-d5cc34;
	while ( b5b567 <= d5cc34)
		read(d5cc34);
		d3 <--- d3 + d5cc34;
		b5b567 <--- b5b567 + 1;
	endwhile
	return [d3];
end

_main 
	record #coordinate
		type int: x;
		type int: y;
	endrecord
	union #four
		type #line : ln; 
		type #point: pt; 
		type #triangle:tr;
	endunion
	definetype union #four as #yash
	record #sourabh
		type #yash: x;
		type int: y;
	endrecord
	type int : b5;
        type real: d2;
        type int: c6: global;
	type int  :d5cb34567;
        type real : d6;
	type real : d7:global; 
	type int : d4 ;
	type real: b5c6 ;
	type int : c2;
	type int : c3c56;
	type int : d6b7;
	type real : c2d5;
	type real : d5c2;
	type real : c2c2;
	type int : c2cc2345;
	type int : c5c5;
	type int : b6b7;
	type real : d7c6;
	type int : b6b6;
	type int : b5b5;
	type record #coordinate: b5cc7;
	b5cc7 <--- b5cc7*5;
	b5cc7 <--- 2*b5cc7;
	b5cc7.x <--- 9.56;      %ERROR : real being set to int
	b5b5 <--- 1/2;
	b5b5 <--- 1.56/1.56;	
	b5b5 <--- 1.56/2;
	b5b5 <--- 2/2.00;
	b6b7 <--- d7c6;
	while ( b6b7 <= b5b5)
		b6b7 <--- b6b7 * 2;
	endwhile
	while ( b6b7 <= d7c6)
		b6b7 <--- b6b7 * 2;
	endwhile
	while ( b6b7 >= d7c6)
		b6b7 <--- b6b7 * 2;
	endwhile
	while ((b6b7>0) &&& (d7c6<0.00))
		b6b7 <--- b6b7 * 2;
	endwhile
	while ((b6b7>0) @@@ (d7c6<0.00))
		b6b7 <--- b6b7 * 2;
	endwhile
	while ((b6b7<0) &&& (b5b5>0))
		b6b7 <--- b6b7 * 2;
	endwhile
	while ((b6b7<0) @@@ (b5b5>0))
		b6b7 <--- b6b7 * 2;
	endwhile
	b5 <--- c6 + d5cb34567 - b5;            % No error
	d7 <--- b5c6 + d5cb34567;  		% ERROR- The expression has a type mismatch as one argument is of integer type and the other is of real type.
	c2d5 <--- d5c2 * c2c2;			% No error
	c2 <--- c3c56 + d6b7*d5cb34567;		% No error
	c2 <--- c3c56 + 23 - d6b7*d5cb34567;	% No error
	c2d5 <--- d5c2 * c2c2 + 23;		% ERROR- The expression has a type mismatch as one argument is of integer type and the other is of real type.	
	c2 <--- 8.52;
	
	return;
end
